/**
 * @file main.cpp
 * @brief Foundational template for an ESP32-S3 LVGL project.
 *
 * This file provides the essential code to initialize the specific hardware of the target device,
 * including the SH8601 display, FT3168 touch controller, and AXP2101 Power Management Unit (PMU).
 * It sets up the LVGL library with the necessary display and input drivers, creating a robust
 * groundwork for building a full user interface.
 */

//################################################################################################
//                                         INCLUDES
//################################################################################################
//** */
#include "lv_conf.h"                    // LVGL's main configuration file - include first
#include <lvgl.h>                       // LVGL graphics library core.
#include <Wire.h>                       // Arduino library for I2C communication (for PMU and Touch).
#include <Arduino.h>                    // Core Arduino framework functionalities.
#include "pin_config.h"                 // Custom header for all board-specific pin and hardware definitions.
#include "XPowersLib.h"                 // Library for the AXP2101 Power Management Unit (PMU).
#include "Arduino_GFX_Library.h"        // Graphics library for driving the display.
#include "Arduino_DriveBus_Library.h"   // Required bus driver library for Arduino_GFX.
#include "display/Arduino_SH8601.h"     // SH8601 display driver
#include "ui.h"                         // UI functions generated by SquareLine Studio.

//################################################################################################
//                                GLOBAL VARIABLES & OBJECTS
//################################################################################################

// --- Power Management ---
XPowersAXP2101 power;                      // Global object for the AXP2101 Power Management Unit.

// --- Display Hardware ---
// This display uses a high-speed QSPI bus.
Arduino_DataBus *bus = new Arduino_ESP32QSPI(
    LCD_CS,    /* Chip Select */
    LCD_SCLK,  /* Serial Clock */
    LCD_SDIO0, /* Serial Data 0 */
    LCD_SDIO1, /* Serial Data 1 */
    LCD_SDIO2, /* Serial Data 2 */
    LCD_SDIO3  /* Serial Data 3 */
);

// GFX driver for the specific SH8601 display controller.
// Note: This must match your physical hardware.
Arduino_SH8601 *gfx = new Arduino_SH8601(
    bus,       /* The QSPI bus object defined above */
    -1,        /* Reset pin (-1 if not used or controlled by other means) */
    0,         /* Default display rotation */
    LCD_WIDTH, /* Display width in pixels (defined in pin_config.h) */
    LCD_HEIGHT /* Display height in pixels (defined in pin_config.h) */
);

// --- Touch Controller ---
// Forward declaration for the touch interrupt function.
void Arduino_IIC_Touch_Interrupt(void);

// Create a shared pointer for the I2C bus that the touch controller will use.
std::shared_ptr<Arduino_IIC_DriveBus> IIC_Bus =
    std::make_shared<Arduino_HWIIC>(IIC_SDA, IIC_SCL, &Wire);

// Create a unique pointer for the FT3168 touch controller driver.
std::unique_ptr<Arduino_IIC> FT3168(new Arduino_FT3x68(
    IIC_Bus,                 /* The I2C bus object */
    FT3168_DEVICE_ADDRESS,   /* The I2C address of the touch chip */
    DRIVEBUS_DEFAULT_VALUE,  /* Default value, not used */
    TP_INT,                  /* The touch interrupt pin */
    Arduino_IIC_Touch_Interrupt /* The function to call on touch interrupt */
));

// --- LVGL Rendering ---
static lv_disp_draw_buf_t draw_buf;                   // LVGL draw buffer structure.
static lv_color_t buf[LCD_WIDTH * LCD_HEIGHT / 10];   // A buffer to hold 1/10th of the screen data. This is a RAM optimization.


//################################################################################################
//                                    FUNCTION DEFINITIONS
//################################################################################################

/**
 * @brief Interrupt service routine for the touch controller.
 * Simply sets a flag when a touch event occurs.
 */
void Arduino_IIC_Touch_Interrupt(void) {
    FT3168->IIC_Interrupt_Flag = true;  // Set the flag that a touch event is pending.
}


/**
 * @brief Flushes a rendered area from the LVGL buffer to the physical display.
 * This function is the bridge between LVGL's software rendering and the hardware driver.
 * @param disp A pointer to the display driver structure.
 * @param area The rectangular area of the screen to update.
 * @param color_p A pointer to the buffer of pixel data to be drawn.
 */
void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p) {
    uint32_t w = (area->x2 - area->x1 + 1); // Calculate the width of the area.
    uint32_t h = (area->y2 - area->y1 + 1); // Calculate the height of the area.

#if (LV_COLOR_16_SWAP != 0)
    // Use the byte-swapped version if LVGL is configured to do so.
    gfx->draw16bitBeRGBBitmap(area->x1, area->y1, (uint16_t *)&color_p->full, w, h);
#else
    // Use the standard version for 16-bit RGB data.
    gfx->draw16bitRGBBitmap(area->x1, area->y1, (uint16_t *)&color_p->full, w, h);
#endif

    lv_disp_flush_ready(disp); // Inform LVGL that the flush operation is complete.
}

/**
 * @brief Reads the touchpad status and coordinates for LVGL.
 * This function is called periodically by LVGL to get the latest touch input data.
 * @param indev_driver A pointer to the input device driver structure.
 * @param data A pointer to a structure where the touch data will be stored.
 */
void my_touchpad_read(lv_indev_drv_t *indev_driver, lv_indev_data_t *data) {
    // Check if the interrupt flag was set by the ISR.
    if (FT3168->IIC_Interrupt_Flag == true) {
        FT3168->IIC_Interrupt_Flag = false; // Clear the flag now that we are processing it.

        // Read the touch coordinates from the controller.
        int32_t touchX = FT3168->IIC_Read_Device_Value(FT3168->Arduino_IIC_Touch::Value_Information::TOUCH_COORDINATE_X);
        int32_t touchY = FT3168->IIC_Read_Device_Value(FT3168->Arduino_IIC_Touch::Value_Information::TOUCH_COORDINATE_Y);
        
        data->state = LV_INDEV_STATE_PR;    // Set the state to "Pressed".
        data->point.x = touchX;             // Assign the X coordinate.
        data->point.y = touchY;             // Assign the Y coordinate.
    } else {
        data->state = LV_INDEV_STATE_REL;   // If no interrupt, set the state to "Released".
    }
}


//################################################################################################
//                                    INITIALIZATION / STARTUP
//################################################################################################

/**
 * @brief The main setup function, run once on boot.
 * Initializes all hardware, drivers, and the LVGL library.
 */
void setup() {
    Serial.begin(115200); // Start serial communication for debugging.

    // Initialize the I2C bus before initializing devices that use it.
    Wire.begin(IIC_SDA, IIC_SCL);

    // Initialize the Power Management Unit (PMU).
    if (!power.begin(Wire, AXP2101_SLAVE_ADDRESS, IIC_SDA, IIC_SCL)) {
        Serial.println("PMU is not online. Halting.");
        while (1) delay(50); // Halt execution if the PMU is critical.
    }
    // Configure basic PMU settings.
    power.setChargeTargetVoltage(XPOWERS_AXP2101_CHG_VOL_4V2);
    power.enableSystemVoltageMeasure(); // Enable ADC for battery monitoring.
    power.enableBattVoltageMeasure();   //

    // Initialize the Touch Controller.
    while (FT3168->begin() == false) {
        Serial.println("FT3168 touch controller initialization fail. Retrying...");
        delay(2000); // Wait before retrying.
    }
    Serial.println("FT3168 initialization successfully.");
    // Put the touch controller into monitor mode to detect touches.
    FT3168->IIC_Write_Device_State(FT3168->Arduino_IIC_Touch::Device::TOUCH_POWER_MODE,
                                 FT3168->Arduino_IIC_Touch::Device_Mode::TOUCH_POWER_MONITOR);

    // Initialize Display Hardware.
    gfx->begin();
    // --- LVGL Core and Driver Initialization ---
    lv_init(); // Initialize the LVGL library.

    // Initialize the display buffer.
    lv_disp_draw_buf_init(&draw_buf, buf, NULL, LCD_WIDTH * LCD_HEIGHT / 10);

    // Initialize the LVGL display driver.
    static lv_disp_drv_t disp_drv;
    lv_disp_drv_init(&disp_drv);
    disp_drv.hor_res = LCD_WIDTH;
    disp_drv.ver_res = LCD_HEIGHT;
    disp_drv.flush_cb = my_disp_flush;
    disp_drv.draw_buf = &draw_buf;
    lv_disp_drv_register(&disp_drv);

    // Initialize the LVGL input device driver (touchpad).
    static lv_indev_drv_t indev_drv;
    lv_indev_drv_init(&indev_drv);
    indev_drv.type = LV_INDEV_TYPE_POINTER;
    indev_drv.read_cb = my_touchpad_read;
    lv_indev_drv_register(&indev_drv);

    // Initialize the UI created with SquareLine Studio.
    // This function (defined in ui.c) creates all the screens and widgets.
    ui_init();

    Serial.println("Setup Complete. UI Initialized.");
}


//################################################################################################
//                                          MAIN LOOP
//################################################################################################

/**
 * @brief The main loop, runs repeatedly after setup.
 * This loop's primary responsibility is to keep LVGL running.
 */
void loop() {
    // This is the heartbeat of LVGL. It handles rendering, animations, and input processing.
    // It should be called as frequently as possible.
    lv_timer_handler();

    // A small delay is crucial to prevent the loop from starving other tasks
    // and to allow the ESP32's underlying OS to function correctly.
    delay(5);
}
